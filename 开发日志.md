# 开发日志

## 2026-02-11
- 记录内容：接入puerts遇到的第一个问题|写下脚本后，编译失败
- Notion标题：CodeAnaly中的大量报错
- 问题：写下Test.ts,使用Rider编译，发现大量报错，报错来源为CodeAnalyze中使用了大量不存在的函数

- 排查过程：
- 1、检查导出的类型文件，发现出错的FileSystemOperation中函数全部都带有_EditorOnly后缀
- 2、检查导出过程代码，发现在导出Function时、会根据PUERTS_WITH_EDITOR_SUFFIX是否定义，来检查函数是否属于Editor函数，而FileSystemOperation所处的PuertsEditor为Editor插件，因此会被判定为true，从而增加后缀
- 解决过程：
- 1、排查PUERTS_WITH_EDITOR_SUFFIX定义源头
- 2、JsEnv中定义了bEditorSuffix，可决定是否开启Eidtor后缀，如果开启则被检查为Editor标记的Fun会带有特定的比后缀
- 解决方式：
- 关闭JsEnv中的bEditorSuffix


进度：
已经可以正确的编译Test.js,同时在Notion中详细记录了如何使用Rider编译TypeScript，以及tsconfig如何配置。

## 2026-02-24
- 将Notion笔记整理到开发日志中，作为Puerts的入门指引
- 从零开始部署PuerTs
  - 安装PuerTs
    - 1、下载PuerTs插件：[Tencent/puerts at DefaultValue_For_UE55](https://github.com/Tencent/puerts/tree/DefaultValue_For_UE55)，可以选择对应引擎版本。
    - 2、将源码放入Client的Plugins目录，以此项目为例可查看PuertsPvpExample\Plugins\Puerts
    - 3、下载JS的V8引擎：[Releases · puerts/backend-v8](https://github.com/puerts/backend-v8/releases)，根据需求自取。
    - 4、将解压好的V8放入Puerts的插件根目录的ThirdParty，注意文件路径需要修剪，以此项目为例：PuertsPvpExample\Plugins\Puerts\ThirdParty\v8_9.4.146.24
    - 5、将更改JsEnv中Build.cs中的V8版本信息，如果需要使用其他虚拟机，自行根据build中的配置进行更改，以此项目为例，需要更改JsEnv.Build.cs::23行为对应的版本
    - 6、右键PuertsPvpExample.uproject->Generate Visual Studio project files
    - 7、使用IDE打开sln文件编译运行
    - 8、启动项目后观察、ToolBar位置会有一个蓝色的按钮，说明安装成功。
    - 9、点击按钮、会生成TS所需的一些相关文件，会卡顿一段时间。
  - 配置Rider
    - Rider原生支持TypeScript的代码分析，我们只需要手动将一些TypeScript的声明文件路径包含到项目中即可使得IDE自动提示生效。如果不清楚TS的声明文件是什么，可以阅读 TypeScript 入门教程 https://ts.xcatliu.com/basics/declaration-files.html
    - 我们编写的TS脚本存放在Root/TypeScript目录中，由TS脚本生成的JavaScript则存放在Content/JavaScript中，上一节点击了生成相关文件，还会生成一个Typing目录，这个目录存放了所有Puerts导出给TS使用的脚本声明，每次点击按钮生成，Puerts都会扫描所有的C++类和蓝图，并导出声明。
    - 我们可以在Rider中右键项目，添加已有文件夹，选择添加现有文件，将TypsScript和Typing、Content/JavaScript添加至解决方案。
    - 等待Rider扫描完毕，我们编写的脚本就可自动识别到UE类型，有正常的高亮提示和跳转。
  - 编写第一个TS脚本
    - 编写HelloWorld/QuickStart.ts（项目内直接搜索脚本查看代码）,于PuertsModule.cpp::243行后查看测试代码
    - 启动PIE，将会看到日志中的Hello World
  - 使用TypeScript集成UE类
    - 首先下载NodeJs，https://nodejs.cn/download/ 下载msi安装包，一路安装并且勾选上安装必要工具
    - 进入PuerTs的插件目录打开cmd，执行命令：node enable_puerts_module.js，启动PuerTS对于TS脚本的实时监控编译
    - 在TS目录编写新的TS脚本TS_Player.ts（项目内直接搜索脚本查看代码），要求文件名和类名必须一致，
    - 正常保存TS后可生成Blueprints/TypeSript/TS_Player蓝图，以及对应的JavaScript
    - 将蓝图拖拽到场景，启动PIE将看到Begin和Tick都会有对应的日志输出
    - 注意：所有的函数必须带返回值，否则将执行失败，js编译时也会有warring日志提醒。
    - 这里可以通过puerts ls或者puerts ls TS_Player查看生成情况，第一字段为脚本内容MD5加密后的加密吗，用来检查变更之类的，isBP代表是否扩展自蓝图。
  - TS脚本和引擎的交互
    - TS脚本的成员变量在蓝图中的表现
      - 修改TS_Player.ts，新增一个StaticMesh组件并保存
      - 查看日志：incremental compile xxx,说明已经出发增量编译，可以查看斌阿姨结果，然后重新打开TS_Player蓝图
      - 可以看到蓝图中多了一个StatcMesh，随意修改蓝图属性并点击蓝图的编译保存
      - 查看原来拖到场景的蓝图,可以看到蓝图保持我们编译后的状态，已经正确保存。
  - 在脚本中调用引擎代码
    - 此部分可查阅项目中的TS_PlayerCharacter，包含一些和引擎交互调用UE原生函数的交互业务。

# Puerts如何为我们生成BP和热更？
  - CodeAnalyze
    - PuertsEditorModule启动过时，如果我们已经开启了自动启用则会创建虚拟机，并启动CodeAnalyze脚本，这应该是Puerts非常核心的代码。
    - 在CodeAnlyze启动后，首先会解析tsconfig，随后监听目录下所有文件的变更，进行一次全量编译，生成蓝图，随后会维护所有脚本的加密字符串，用于后续热更。
    - 当然此处还有大量代码未探索，我们只需知道这些能力是在这里提供的。

# 虚拟机是如何启动的，我们的JS代码如何绑定到Object？
  - 1、虚拟机何时启动：
    - 主要逻辑基本几种在PuertsModule下，PuerTsModule启动后会加载Puerts.ini配置，并监听PIE事件，分别在启用和关闭时创建和销毁虚拟机。
    - 创建虚拟机时将传递大量参数，比如JS文件路径，日志，调试端口等。
  - 2、何时绑定JS
    - 虚拟机创建完毕后，会调用到JsEnv->RebindJs()
    - 在这里将会遍历World中所有非Native的Class对于UTypeScriptGeneratedClass类重新注入刷新重定向，确保子类使用的是UTypeScriptGeneratedClass的构造，同时还会刷新GeneratedObjects的缓存，应该是后续热更新也会用到，可以到这里直接重新刷新。
  - 3、如何将Object绑定到JS
    - PuertsModule继承自ObjectCreateListener，Object创建后会调用到NotifyUObjectCreated，进而调用到虚拟机JsEnv->TryBindJs，进行绑定。
    - 绑定时会将DynamicInvoker和ClassConstructor全部重定向到JS中，关键代码可查阅JsEnvImple::1569 - 1584,可以看到重定向的过程，Object的函数将最终执行到&UTypeScriptGeneratedClass::execLazyLoadCallJS,在使用前进行绑定、重置、执行JS代码等
  - 4、蓝图调用Ts的过程
    - 蓝图Fun->TS::execCallJS->PinedDynamicInvoker->InvokeTsMethod(Context, Func, Stack, RESULT_PARAM)->V8调用到JS，执行函数并返回结果，
    - 具体代码可查阅TypeScriptGeneratedClass::57行